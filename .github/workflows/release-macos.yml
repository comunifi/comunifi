name: Release macOS

on:
  workflow_dispatch:

jobs:
  build-and-release:
    runs-on: macos-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Extract version from pubspec.yaml
        id: version
        run: |
          VERSION=$(grep '^version:' pubspec.yaml | sed 's/version: //' | sed 's/+.*//')
          echo "version=${VERSION}" >> $GITHUB_OUTPUT
          echo "Extracted version: ${VERSION}"

      - name: Create .env file
        run: |
          # Generate a new Ethereum private key (32 bytes = 64 hex chars, no 0x prefix)
          PRIVATE_KEY=$(openssl rand -hex 32)

          cat > .env << EOF
          RELAY_URL=${{ secrets.RELAY_URL }}
          CLIENT_SIGNATURE_PRIVATE_KEY=${PRIVATE_KEY}
          EOF

      - name: Create empty .env.debug file
        run: |
          touch .env.debug

      - name: Setup Flutter
        uses: subosito/flutter-action@v2
        with:
          channel: stable
          cache: true

      - name: Install Apple certificate
        env:
          CERTIFICATE_BASE64: ${{ secrets.MACOS_CERTIFICATE_BASE64 }}
          CERTIFICATE_PASSWORD: ${{ secrets.MACOS_CERTIFICATE_PASSWORD }}
          KEYCHAIN_PASSWORD: ${{ secrets.MACOS_CERTIFICATE_PASSWORD }}
        run: |
          # Create variables
          CERTIFICATE_PATH=$RUNNER_TEMP/certificate.p12
          KEYCHAIN_PATH=$RUNNER_TEMP/app-signing.keychain-db

          # Decode certificate
          echo -n "$CERTIFICATE_BASE64" | base64 --decode -o $CERTIFICATE_PATH

          # Create temporary keychain
          security create-keychain -p "$KEYCHAIN_PASSWORD" $KEYCHAIN_PATH
          security set-keychain-settings -lut 21600 $KEYCHAIN_PATH
          security unlock-keychain -p "$KEYCHAIN_PASSWORD" $KEYCHAIN_PATH

          # Import certificate to keychain
          security import $CERTIFICATE_PATH -P "$CERTIFICATE_PASSWORD" -A -t cert -f pkcs12 -k $KEYCHAIN_PATH
          security set-key-partition-list -S apple-tool:,apple: -k "$KEYCHAIN_PASSWORD" $KEYCHAIN_PATH
          security list-keychain -d user -s $KEYCHAIN_PATH

      - name: Install dependencies
        run: flutter pub get

      - name: Install CocoaPods
        run: |
          cd macos
          pod install

      - name: Install fastforge
        run: dart pub global activate fastforge

      - name: Setup Sparkle private key
        run: |
          # Import the Sparkle private key for signing updates
          echo "${{ secrets.SPARKLE_PRIVATE_KEY }}" | ./macos/Pods/Sparkle/bin/generate_keys -f /dev/stdin

      - name: Build macOS app (unsigned)
        run: |
          # Build the app without code signing first
          flutter build macos --release \
            --config-only

          # Build using xcodebuild without signing
          xcodebuild -workspace macos/Runner.xcworkspace \
            -scheme Runner \
            -configuration Release \
            -derivedDataPath build/macos \
            CODE_SIGNING_REQUIRED=NO \
            CODE_SIGNING_ALLOWED=NO \
            CODE_SIGN_IDENTITY="-"

      - name: Sign app with Developer ID
        env:
          APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
        run: |
          APP_PATH="build/macos/Build/Products/Release/Comunifi.app"

          # Find the signing identity
          IDENTITY=$(security find-identity -v -p codesigning | grep "Developer ID Application" | head -1 | awk -F'"' '{print $2}')
          echo "Using identity: $IDENTITY"

          # Sign all frameworks and dylibs inside the app first (deep signing)
          find "$APP_PATH" -type f \( -name "*.framework" -o -name "*.dylib" \) -exec \
            codesign --force --timestamp --options=runtime --sign "$IDENTITY" {} \;

          # Sign all .app bundles inside (like Sparkle's updater)
          find "$APP_PATH" -type d -name "*.app" -exec \
            codesign --force --timestamp --options=runtime --sign "$IDENTITY" {} \;

          # Sign all frameworks directories
          find "$APP_PATH/Contents/Frameworks" -type d -name "*.framework" -exec \
            codesign --force --timestamp --options=runtime --sign "$IDENTITY" {} \;

          # Sign the main app bundle
          codesign --force --timestamp --options=runtime --sign "$IDENTITY" "$APP_PATH"

          # Verify the signature
          codesign --verify --deep --strict --verbose=2 "$APP_PATH"

      - name: Create DMG
        run: |
          # Create output directory
          mkdir -p dist

          # Get app name and create DMG
          APP_NAME="Comunifi"
          APP_PATH="build/macos/Build/Products/Release/${APP_NAME}.app"
          DMG_NAME="comunifi-${{ steps.version.outputs.version }}.dmg"

          # Verify app exists
          if [ ! -d "${APP_PATH}" ]; then
            echo "App not found at ${APP_PATH}, checking alternative location..."
            APP_PATH=$(find build/macos -name "*.app" -type d | head -1)
            echo "Found app at: ${APP_PATH}"
          fi

          # Create DMG using hdiutil
          hdiutil create -volname "${APP_NAME}" -srcfolder "${APP_PATH}" -ov -format UDZO "dist/${DMG_NAME}"

      - name: Notarize DMG
        env:
          APPLE_ID: ${{ secrets.APPLE_ID }}
          APPLE_APP_PASSWORD: ${{ secrets.APPLE_APP_PASSWORD }}
          APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
        run: |
          DMG_PATH="dist/comunifi-${{ steps.version.outputs.version }}.dmg"

          # Submit for notarization and capture output
          SUBMIT_OUTPUT=$(xcrun notarytool submit "${DMG_PATH}" \
            --apple-id "${APPLE_ID}" \
            --password "${APPLE_APP_PASSWORD}" \
            --team-id "${APPLE_TEAM_ID}" \
            --wait 2>&1) || true

          echo "$SUBMIT_OUTPUT"

          # Extract submission ID
          SUBMISSION_ID=$(echo "$SUBMIT_OUTPUT" | grep "id:" | head -1 | awk '{print $2}')
          echo "Submission ID: $SUBMISSION_ID"

          # Check if notarization succeeded
          if echo "$SUBMIT_OUTPUT" | grep -q "status: Accepted"; then
            echo "Notarization succeeded!"
            # Staple the notarization ticket
            xcrun stapler staple "${DMG_PATH}"
          else
            echo "Notarization failed. Fetching log..."
            xcrun notarytool log "$SUBMISSION_ID" \
              --apple-id "${APPLE_ID}" \
              --password "${APPLE_APP_PASSWORD}" \
              --team-id "${APPLE_TEAM_ID}"
            exit 1
          fi

      - name: Sign update for Sparkle
        id: sign
        run: |
          DMG_PATH="dist/comunifi-${{ steps.version.outputs.version }}.dmg"

          # Sign the DMG and capture the signature
          SIGNATURE=$(./macos/Pods/Sparkle/bin/sign_update "${DMG_PATH}" | grep "sparkle:edSignature" | sed 's/.*sparkle:edSignature="\([^"]*\)".*/\1/')
          DMG_SIZE=$(stat -f%z "${DMG_PATH}")

          echo "signature=${SIGNATURE}" >> $GITHUB_OUTPUT
          echo "size=${DMG_SIZE}" >> $GITHUB_OUTPUT

      - name: Generate appcast.xml
        run: |
          VERSION="${{ steps.version.outputs.version }}"
          SIGNATURE="${{ steps.sign.outputs.signature }}"
          SIZE="${{ steps.sign.outputs.size }}"
          PUB_DATE=$(date -R)

          cat > dist/appcast.xml << EOF
          <?xml version="1.0" encoding="utf-8"?>
          <rss version="2.0"
              xmlns:sparkle="http://www.andymatuschak.org/xml-namespaces/sparkle"
              xmlns:dc="http://purl.org/dc/elements/1.1/">
              <channel>
                  <title>Comunifi Updates</title>
                  <link>https://github.com/comunifi/comunifi/releases</link>
                  <description>Most recent updates to Comunifi</description>
                  <language>en</language>
                  <item>
                      <title>Version ${VERSION}</title>
                      <sparkle:version>${VERSION}</sparkle:version>
                      <sparkle:shortVersionString>${VERSION}</sparkle:shortVersionString>
                      <pubDate>${PUB_DATE}</pubDate>
                      <sparkle:minimumSystemVersion>10.15</sparkle:minimumSystemVersion>
                      <enclosure url="https://github.com/comunifi/comunifi/releases/download/v${VERSION}/comunifi-${VERSION}.dmg" sparkle:edSignature="${SIGNATURE}" length="${SIZE}" type="application/octet-stream"/>
                      <sparkle:releaseNotesLink>https://github.com/comunifi/comunifi/releases/tag/v${VERSION}</sparkle:releaseNotesLink>
                  </item>
              </channel>
          </rss>
          EOF

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v1
        with:
          tag_name: v${{ steps.version.outputs.version }}
          name: v${{ steps.version.outputs.version }}
          draft: false
          prerelease: false
          files: |
            dist/comunifi-${{ steps.version.outputs.version }}.dmg
            dist/appcast.xml
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Cleanup keychain
        if: always()
        run: |
          security delete-keychain $RUNNER_TEMP/app-signing.keychain-db || true
